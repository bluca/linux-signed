#!/usr/bin/make -f
SHELL := bash -e

include /usr/share/dpkg/default.mk

# When forking to a new signed package, it should be enough to change
# the following two variables:
# - where to look for unsigned EFI binaries, and where to install them
# - unsigned package name
EFI_INSTALL_DIR := /boot
UNSIGNED_PACKAGE_NAME := $(shell dpkg -S /boot/vmlinuz-* | sed "s/\(.*\):.*/\1/")

PACKAGE_NAME := $(shell dpkg -S /boot/vmlinuz-* | sed "s/\(.*\):.*/\1/" | sed "s/-unsigned//")-signed
PACKAGE_DIR := debian/$(PACKAGE_NAME)
INSTALL_DIR := $(PACKAGE_DIR)/$(EFI_INSTALL_DIR)
PACKAGE_VERSION := $(shell dpkg-query --showformat='$${Version}' --show $(UNSIGNED_PACKAGE_NAME))
SIGNED_SUFFIX := ""

# Building in an OBS worker chroot or locally? Source build will fail otherwise
ifneq ("$(wildcard /usr/src/packages/SOURCES)","")
# Generate package metadata at build time - need to override build to make sure
# it's done before the dh sequencer starts or things will break (generated
# package(s) will not be acted on). With some version of dpkg + debhelper build
# can run twice, so take care not to do the mangling twice.
build:
	if ! grep -q "$(PACKAGE_NAME)" debian/control; then \
		sed -i "/Package:/d" debian/control; \
		sed -i "/Architecture:/d" debian/control; \
		sed -i "/^Depends:/d" debian/control; \
		echo "Package: $(PACKAGE_NAME)" >> debian/control; \
		for PARAM in Architecture Depends Recommends Suggests Replaces Breaks Conflicts; do \
			echo "$$PARAM: $$(dpkg-query --showformat="\$${$$PARAM}" --show $(UNSIGNED_PACKAGE_NAME))" \
				>> debian/control; \
		done; \
		echo "Provides: linux-image-$(DEB_HOST_ARCH)-signed, $(shell dpkg-query --showformat='$${Provides}' --show $(UNSIGNED_PACKAGE_NAME))" >> debian/control; \
		echo "Description: kernel image (signed)" >> debian/control; \
		echo " This package ships a UEFI Secure Boot enabled signed image" >> debian/control; \
		for SCRIPT in $$(dpkg-query --control-list $(UNSIGNED_PACKAGE_NAME) | grep -v "md5sums"); do \
			dpkg-query --control-show $(UNSIGNED_PACKAGE_NAME) $$SCRIPT \
				> debian/$(PACKAGE_NAME).$$SCRIPT; \
		done; \
	fi;
	dh $@
endif

%:
	dh $@

# Build with the original's version, changelog and copyright, as it makes
# more sense to have it match the unsigned binary

# Generate a strict dependency - the unsigned and signed packages must match
override_dh_gencontrol:
	dh_gencontrol -p $(PACKAGE_NAME) -- -v$(PACKAGE_VERSION) \
		-V'sign:Depends=$(UNSIGNED_PACKAGE_NAME) (= $(PACKAGE_VERSION))'

override_dh_installchangelogs:
	dh_installchangelogs
	gunzip -c /usr/share/doc/$(UNSIGNED_PACKAGE_NAME)/changelog.Debian.gz > \
		$(PACKAGE_DIR)/usr/share/doc/$(PACKAGE_NAME)/changelog

override_dh_installdocs:
	dh_installdocs
	cp /usr/share/doc/$(UNSIGNED_PACKAGE_NAME)/copyright \
		$(PACKAGE_DIR)/usr/share/doc/$(PACKAGE_NAME)/

# On the first pass extract the signature(s), package them as signd expects and
# store them in the OTHER directory. This will trigger the signer, which will
# place the cpio archive with the signatures in the SOURCES directory and restart
# the build.
# During this second pass unpack the signatures and the corresponding hashes and
# apply them to the binary with pesign, and install them with the .signed suffix.
# The dummy certutil DB is necessary otherwise pesign will refuse to work.
# The symlinks for the vmlinuz and initrd.img are hacks for live-build - given the
# package name is -signed, the live-buid flavour has to be $arch-signed but that's
# also used for the grub cfg filename, so we need a symlink. We have to use the
# -signed suffix for the package otherwise this source package would build-depend
# on itself and cause a build loop on OBS.
override_dh_auto_install:
	if [ ! -f ../SOURCES/$(UNSIGNED_PACKAGE_NAME).cpio.rsasign.sig ]; then \
		nss_db=$$PWD/nss-db; \
		mkdir -p $$nss_db; \
		certutil -N -d sql:"$$nss_db" --empty-password; \
		for f in $$(find $(EFI_INSTALL_DIR) -type f -name "vmlinuz-*" -o -type f -name "*.efi"); do \
			pesign -n sql:"$$nss_db" -i $$f -E $${f##*/}.hash; \
		done; \
		find . -type f -name "*.hash" | cpio -H newc -o > ../OTHER/$(UNSIGNED_PACKAGE_NAME).cpio.rsasign; \
		rm -rf $$nss_db;\
	else \
		mkdir nss-db; \
		nss_db=$$PWD/nss-db; \
		certutil -N -d sql:"$$nss_db" -f "$$nss_db/passwd" --empty-password; \
		certutil -A -d sql:"$$nss_db" -n cert -t CT,CT,CT -i ../SOURCES/_projectcert.crt; \
		mkdir -p $(INSTALL_DIR); \
		cpio -idm < ../SOURCES/$(UNSIGNED_PACKAGE_NAME).cpio.rsasign.sig; \
		while read SIG; do \
			export infile=$${SIG%.sig}; \
			cpio -i --to-stdout $${infile#*/} < ../SOURCES/$(UNSIGNED_PACKAGE_NAME).cpio.rsasign > $${infile}.sattrs; \
			test -s $${infile}.sattrs || exit 1; \
			pesign -n sql:"$$nss_db" -c cert -i $(EFI_INSTALL_DIR)/$${SIG%.hash.sig} -o $(INSTALL_DIR)/"$${SIG%.hash.sig}"$(SIGNED_SUFFIX) -d sha256 -I "$${infile}.sattrs" -R "$$SIG"; \
		done < <(find -type f -name '*.sig' -printf '%P\n'); \
		rm -rf $$nss_db; \
		mkdir -p $(PACKAGE_DIR)/lib/modules; \
		for f in $$(find $(EFI_INSTALL_DIR) -type f -name "vmlinuz-*" -printf '%P\n'); do \
			cp -r /lib/modules/$${f##vmlinuz-} $(PACKAGE_DIR)/lib/modules/; \
			cp $(EFI_INSTALL_DIR)/System.map-$${f##vmlinuz-} $(INSTALL_DIR)/; \
			cp $(EFI_INSTALL_DIR)/config-$${f##vmlinuz-} $(INSTALL_DIR)/; \
			dh_link -p $(PACKAGE_NAME) /boot/$$f /boot/$$f-signed; \
			dh_link -p $(PACKAGE_NAME) /boot/initrd.img-$${f##vmlinuz-} /boot/initrd.img-$${f##vmlinuz-}-signed; \
		done; \
	fi

override_dh_strip:
	# Avoid stripping signatures, especially with kernel modules,
	# the binaries have already been stripped in the actual build
